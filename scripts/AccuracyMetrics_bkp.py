# -*- coding: utf-8 -*-

"""
/***************************************************************************
 samaple
                                 A QGIS plugin
 A user-friendly tool for semi-automatic mapping and accuracy analysis in plot-level experiments
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-02-16
        copyright            : (C) 2024 by Tales Abrantes
        email                : abrantales@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

"""
***************************************************************************
    AccuracyMetrics.py
***************************************************************************
"""

__author__ = 'Tales Abrantes'
__date__ = '2024-02-16'
__copyright__ = '(C) 2024 by Tales Abrantes'

__revision__ = '$Format:%H$'


from qgis.core import (QgsProcessing,
                      QgsProcessingAlgorithm,
                      QgsProcessingParameterVectorLayer,
                      QgsProcessingParameterField,
                      QgsProcessingParameterFeatureSink,
                      QgsProcessingException,
                      QgsFields,
                      QgsField,
                      QgsWkbTypes,
                      QgsMessageLog,
                      Qgis,
                      QgsVectorLayer,
                      QgsFeature,
                      QgsGeometry,
                      QgsProject
                      )

from PyQt5.QtCore import QCoreApplication, QVariant
import os
import tempfile
import geopandas as gpd
import numpy as np
import pandas as pd
import logging
import random
import string



class AccuracyMetrics(QgsProcessingAlgorithm):
    """
    Accuracy Metrics
    """

    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
    OBSERVED_VALUE = 'OBSERVED_DATA'
    ESTIMATED_VALUE = 'ESTIMATED_DATA'


    def __init__(self):
        self.dest_id = ''
        super().__init__()

    def initAlgorithm(self, config):
        self.addParameter(QgsProcessingParameterVectorLayer(self.INPUT, self.tr('Input Vector Layer'), types=[QgsProcessing.TypeVectorPoint, QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Output Vector Layer'), createByDefault=True, supportsAppend=False, defaultValue=None, type=QgsProcessing.TypeVectorAnyGeometry))
        self.addParameter(QgsProcessingParameterField(self.OBSERVED_VALUE, self.tr('Observed Data Field'), parentLayerParameterName=self.INPUT, type=QgsProcessingParameterField.Numeric, allowMultiple=False))
        self.addParameter(QgsProcessingParameterField(self.ESTIMATED_VALUE, self.tr('Estimated Data Field'), parentLayerParameterName=self.INPUT, type=QgsProcessingParameterField.Numeric, allowMultiple=False))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        dest_id = None

        # Extract parameters
        layer_source, observed_field, estimated_field = self.extractParameters(parameters, context)

        # Prepare data
        data = self.prepareData(layer_source, observed_field, estimated_field)

        # Calculate Accuracy Metrics
        data = self.calculateError(data, observed_field, estimated_field)
        data = self.calculateAbsoluteError(data, observed_field, estimated_field)
        data = self.calculateRelativeError(data, observed_field, estimated_field)
        data = self.calculateAbsoluteRelativeError(data, observed_field, estimated_field)
        data = self.calculateAbsoluteError(data, observed_field, estimated_field)

        # Handle output
        dest_id = self.handleOutput(data, parameters, context, layer_source)

        return {self.OUTPUT: dest_id}

    def extractParameters(self, parameters, context):
        """
        Extract the parameters that will be used.
        """
        layer_source = self.parameterAsVectorLayer(parameters, self.INPUT, context)
        observed_field = self.parameterAsString(parameters, self.OBSERVED_VALUE, context)
        estimated_field = self.parameterAsString(parameters, self.ESTIMATED_VALUE, context)

        # Debugging output
        QgsMessageLog.logMessage(f"Observed Field: {observed_field}", 'Accuracy Metrics', Qgis.Info)
        QgsMessageLog.logMessage(f"Estimated Field: {estimated_field}", 'Accuracy Metrics', Qgis.Info)
        QgsMessageLog.logMessage(f"Available Fields: {[field.name() for field in layer_source.fields()]}", 'Accuracy Metrics', Qgis.Info)

        # Check if the observed and estimated fields are valid
        observed_field_index = layer_source.fields().indexFromName(observed_field)
        estimated_field_index = layer_source.fields().indexFromName(estimated_field)

        QgsMessageLog.logMessage(f"Observed Field Index: {observed_field_index}", 'Accuracy Metrics', Qgis.Info)
        QgsMessageLog.logMessage(f"Estimated Field Index: {estimated_field_index}", 'Accuracy Metrics', Qgis.Info)

        if observed_field_index == -1 or estimated_field_index == -1:
            raise QgsProcessingException('Invalid observed or estimated field.')

        return layer_source, observed_field, estimated_field


    def prepareData(self, layer_source, observed_field, estimated_field):
        try:
            if isinstance(layer_source, QgsVectorLayer):
                layer = layer_source
            else:
                layer = QgsVectorLayer(layer_source, 'temp_layer', 'ogr')

            if not layer.isValid():
                raise Exception('Failed to create QgsVectorLayer from input')

            data = self.qgisVectorLayerToGeoDataFrame(layer)
            return data

        except Exception as e:
            logging.error(f"An error occurred during data preparation: {e}")
            raise
            

    def qgisVectorLayerToGeoDataFrame(self, layer_source):
        try:
            fields = layer_source.fields()
            field_names = [field.name() for field in fields]
            data = {
                field_name: [feature[field_name] for feature in layer_source.getFeatures()] for field_name in
                field_names
            }

            geometry = [feature.geometry().asWkt() for feature in layer_source.getFeatures()]
            data['geometry'] = geometry

            gdf = gpd.GeoDataFrame(data, geometry=gpd.GeoSeries.from_wkt(geometry), crs=layer_source.crs().toProj4())
            return gdf

        except Exception as e:
            logging.exception(f"An error occurred during data preparation: {e}")
            raise

    def calculateError(self, data, observed_field, estimated_field):
        """
        Calculate the Error.
        """
        data['Error'] = data[observed_field] - data[estimated_field]
        return data


    def calculateAbsoluteError(self, data, observed_field, estimated_field):
        """
        Calculate the Absolute Error.
        """
        data['Absolute Error'] = np.abs(data['Error'])
        return data
    

    def calculateRelativeError(self, data, observed_field, estimated_field):
        """
        Calculate the Relative Error.
        """
        data['Relative Error'] = data['Error'] / data[observed_field]
        return data

    def calculateAbsoluteRelativeError(self, data, observed_field, estimated_field):
        """
        Calculate the Absolute Relative Error.
        """
        data['Absolute Relative Error'] = np.abs(data['Relative Error'])
        return data



    def handleOutput(self, data, parameters, context, layer_source):
        """
        Handle the output layer containing the calculated error and the input layer parameters.
        """
        try:
            # Shorten column name
            # data.rename(columns={'Error': 'Error'}, inplace=True)
            data.rename(columns={'Absolute Error': 'Abs_Error'}, inplace=True)
            data.rename(columns={'Relative Error': 'Rel_Error'}, inplace=True)
            data.rename(columns={'Absolute Relative Error': 'Abs_Rel_Error'}, inplace=True)

            rand_ext = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
            out_path = os.path.join(tempfile.gettempdir(), f'temp_output{rand_ext}.shp')

            # Save GeoDataFrame to a shapefile
            data.to_file(out_path)

            # Create a QgsVectorLayer using the saved shapefile
            vector_layer = QgsVectorLayer(out_path, "Accuracy Metrics", "ogr")
            vector_layer.setCrs(layer_source.crs())

            # Print debug information
            QgsMessageLog.logMessage(f"Original layer fields: {[field.name() for field in layer_source.fields()]}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Vector layer fields: {[field.name() for field in vector_layer.fields()]}", 'Accuracy Metrics', Qgis.Info)

            # Use the source layer's fields when creating the sink
            fields = layer_source.fields()

            # Add the 'Abs_Error' field to the fields
            fields.append(QgsField('Error', QVariant.Double))
            fields.append(QgsField('Abs_Error', QVariant.Double))
            fields.append(QgsField('Rel_Error', QVariant.Double))
            fields.append(QgsField('Abs_Rel_Error', QVariant.Double))

            # Print debug information
            QgsMessageLog.logMessage(f"Fields for sink: {[field.name() for field in fields]}", 'Accuracy Metrics', Qgis.Info)

            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields,
                                                QgsWkbTypes.Point, layer_source.crs())

            # Add features directly from the vector layer
            for feature in vector_layer.getFeatures():
                sink.addFeature(feature)

            return dest_id
        except Exception as e:
            QgsMessageLog.logMessage(f'Error handling output layer: {e}', 'Accuracy Metrics', level=Qgis.Critical)
            return 'TEMPORARY_OUTPUT_LAYER'  # Use a different name for the temporary layer





    def name(self):
        return 'Accuracy Metrics'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Accuracy'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def shortHelpString(self):
        return ("Accuracy Metrics. \n"
                "Performs accuracy analysis.")

    def createInstance(self):
        return AccuracyMetrics()

    def icon(self):
        from qgis.PyQt.QtGui import QIcon
        import os
        pluginPath = os.path.dirname(__file__)
        return QIcon(os.path.join(pluginPath, 'styles', 'icon.png'))