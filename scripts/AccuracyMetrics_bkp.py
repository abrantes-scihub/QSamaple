# -*- coding: utf-8 -*-

"""
/***************************************************************************
 samaple
                                 A QGIS plugin
 A user-friendly tool for semi-automatic mapping and accuracy analysis in plot-level experiments
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-02-16
        copyright            : (C) 2024 by Tales Abrantes
        email                : abrantales@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

"""
***************************************************************************
    AccuracyMetrics.py
***************************************************************************
"""

__author__ = 'Tales Abrantes'
__date__ = '2024-02-16'
__copyright__ = '(C) 2024 by Tales Abrantes'

__revision__ = '$Format:%H$'


from qgis.core import (QgsProcessing,
                      QgsProcessingAlgorithm,
                      QgsProcessingParameterVectorLayer,
                      QgsProcessingParameterField,
                      QgsProcessingParameterFeatureSink,
                      QgsProcessingException,
                      QgsFields,
                      QgsField,
                      QgsWkbTypes,
                      QgsMessageLog,
                      Qgis,
                      QgsVectorLayer,
                      QgsFeature,
                      QgsGeometry,
                      QgsProject,
                      )

from PyQt5.QtCore import QCoreApplication, QVariant
import os
import tempfile
import geopandas as gpd
import numpy as np
import pandas as pd
import logging
import random
import string

####################################################################################################
########################### The main class for processing the algorithms ###########################
####################################################################################################

class AccuracyMetrics(QgsProcessingAlgorithm):
    """
    Processing functions for accuracy metrics
    """

    # Constants for parameters
    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
    MEASURED_VALUE = 'MEASURED_DATA'
    ESTIMATED_VALUE = 'ESTIMATED_DATA'
    CASE_FIELD = 'CASE_FIELD'


    def __init__(self):
        self.dest_id = ''
        super().__init__()

    def initAlgorithm(self, config):
        self.addParameter(QgsProcessingParameterVectorLayer(self.INPUT, self.tr('Input Vector Layer'), types=[QgsProcessing.TypeVectorPoint, QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr('Output Vector Layer'), createByDefault=True, supportsAppend=False, defaultValue=None, type=QgsProcessing.TypeVectorAnyGeometry))
        self.addParameter(QgsProcessingParameterField(self.MEASURED_VALUE, self.tr('Measured Data Field'), parentLayerParameterName=self.INPUT, type=QgsProcessingParameterField.Numeric, allowMultiple=False))
        self.addParameter(QgsProcessingParameterField(self.ESTIMATED_VALUE, self.tr('Estimated Data Field'), parentLayerParameterName=self.INPUT, type=QgsProcessingParameterField.Numeric, allowMultiple=False))
        self.addParameter(QgsProcessingParameterField(self.CASE_FIELD, self.tr('Case Field'), parentLayerParameterName=self.INPUT, type=QgsProcessingParameterField.Any, allowMultiple=False, optional=True))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        dest_id = None

        # Extract parameters
        layer_source, measured_field, estimated_field, case_field = self.extractParameters(parameters, context)

        # First call to prepareData
        data = self.prepareData(layer_source, measured_field, estimated_field, case_field)


        # Second call to prepareData
        data = AccuracyMetricsUtils.calculateError(self, data, measured_field, estimated_field)
        data = AccuracyMetricsUtils.calculateAbsoluteError(self, data, measured_field, estimated_field)
        data = AccuracyMetricsUtils.calculateRelativeError(self, data, measured_field, estimated_field)
        data = AccuracyMetricsUtils.calculateAbsoluteRelativeError(self, data, measured_field, estimated_field)

        # If case_field is specified, calculate Mean Absolute Error separately for each class
        if case_field:
            data = AccuracyMetricsUtils.calculateMeanAbsoluteError(self, data, measured_field, estimated_field, case_field)
        else:
            # Otherwise, calculate Mean Absolute Error for the entire dataset
            data = AccuracyMetricsUtils.calculateMeanAbsoluteError(self, data, measured_field, estimated_field)

        # Handle output
        dest_id = self.handleOutput(data, parameters, context, layer_source)

        return {self.OUTPUT: dest_id}


    def extractParameters(self, parameters, context):
        """
        Extract the parameters that will be used.
        """
        layer_source = self.parameterAsVectorLayer(parameters, self.INPUT, context)
        measured_field = self.parameterAsString(parameters, self.MEASURED_VALUE, context)
        estimated_field = self.parameterAsString(parameters, self.ESTIMATED_VALUE, context)
        case_field = self.parameterAsString(parameters, self.CASE_FIELD, context)

        # Prepare data
        data = self.prepareData(layer_source, measured_field, estimated_field, case_field)

        return layer_source, measured_field, estimated_field, case_field



    def prepareData(self, layer_source, measured_field, estimated_field, case_field):
        try:
            if isinstance(layer_source, QgsVectorLayer):
                layer = layer_source
            else:
                layer = QgsVectorLayer(layer_source, 'temp_layer', 'ogr')

            if not layer.isValid():
                raise Exception('Failed to create QgsVectorLayer from input')

            data = self.qgisVectorLayerToGeoDataFrame(layer)

            # Debugging output for data structure and types
            QgsMessageLog.logMessage(f"Type of prepared data: {type(data)}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Columns of prepared data: {data.columns}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Structure of prepared data: {data.head()}", 'Accuracy Metrics', Qgis.Info)

            return data

        except Exception as e:
            logging.error(f"An error occurred during data preparation: {e}")
            raise



    def qgisVectorLayerToGeoDataFrame(self, layer_source):
        try:
            fields = layer_source.fields()
            field_names = [field.name() for field in fields]
            data = {
                field_name: [feature[field_name] for feature in layer_source.getFeatures()] for field_name in field_names
            }

            geometry = [feature.geometry().asWkt() for feature in layer_source.getFeatures()]
            data['geometry'] = geometry

            gdf = gpd.GeoDataFrame(data, geometry=gpd.GeoSeries.from_wkt(geometry), crs=layer_source.crs().toProj4())
            return gdf

        except Exception as e:
            logging.exception(f"An error occurred during data preparation: {e}")
            raise





    def handleOutput(self, data, parameters, context, layer_source):
        try:
            # Shorten column name
            data.rename(columns={'Absolute Error': 'Abs_Error', 'Relative Error': 'Rel_Error', 'Absolute Relative Error': 'Abs_Rel_Error', 'Mean Absolute Error': 'M_Abs_E'}, inplace=True)

            rand_ext = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
            out_path = os.path.join(tempfile.gettempdir(), f'temp_output{rand_ext}.shp')

            # Save GeoDataFrame to a shapefile
            data.to_file(out_path)

            # Create a QgsVectorLayer using the saved shapefile
            vector_layer = QgsVectorLayer(out_path, "Accuracy Metrics", "ogr")
            vector_layer.setCrs(layer_source.crs())

            # Print debug information
            QgsMessageLog.logMessage(f"Original layer fields: {[field.name() for field in layer_source.fields()]}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Vector layer fields: {[field.name() for field in vector_layer.fields()]}", 'Accuracy Metrics', Qgis.Info)

            # Use the source layer's fields when creating the sink
            fields = layer_source.fields()

            # Add the 'Abs_Error' field to the fields
            fields.append(QgsField('Error', QVariant.Double))
            fields.append(QgsField('Abs_Error', QVariant.Double))
            fields.append(QgsField('Rel_Error', QVariant.Double))
            fields.append(QgsField('Abs_Rel_Error', QVariant.Double))
            fields.append(QgsField('M_Abs_E', QVariant.Double))

            # Add case field if present
            case_field = self.parameterAsString(parameters, self.CASE_FIELD, context)
            if case_field:
                # Check if the case field is already present in the source layer's fields
                if case_field not in [field.name() for field in fields]:
                    fields.append(QgsField(case_field, QVariant.String))

            (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, fields,
                                                QgsWkbTypes.Point, layer_source.crs())

            # Add features directly from the vector layer
            for feature in vector_layer.getFeatures():
                if case_field:
                    # Add the case field value to the sink
                    case_value = data.loc[feature.id(), case_field]
                    # Ensure the case value is not empty before setting the attribute
                    if not pd.isna(case_value):
                        feature.setAttribute(case_field, str(case_value))
                sink.addFeature(feature)

            return dest_id
        except Exception as e:
            QgsMessageLog.logMessage(f'Error handling output layer: {e}', 'Accuracy Metrics', level=Qgis.Critical)
            return 'TEMPORARY_OUTPUT_LAYER'  # Use a different name for the temporary layer



    """
    Metadata for the Accuracy Metrics algorithm
    """
    def name(self):
        return 'Accuracy Metrics'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Accuracy'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def shortHelpString(self):
        return ("Accuracy Metrics. \n"
                "Performs accuracy analysis.")

    def createInstance(self):
        return AccuracyMetrics()

    def icon(self):
        from qgis.PyQt.QtGui import QIcon
        import os
        pluginPath = os.path.dirname(__file__)
        return QIcon(os.path.join(pluginPath, 'styles', 'icon.png'))

####################################################################################################
######################################## Utility functions #########################################
####################################################################################################
        
class AccuracyMetricsUtils:
    """
    Utility functions for calculating accuracy
    """	
    @staticmethod
    def calculateError(self, data, measured_field, estimated_field):
        try:
            # Log information about the data
            QgsMessageLog.logMessage(f"Type of data: {type(data)}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Columns of data: {data.columns}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Structure of data: {data.head()}", 'Accuracy Metrics', Qgis.Info)

            # Calculate the error
            data['Error'] = data[measured_field] - data[estimated_field]
            
            # Add debug messages
            QgsMessageLog.logMessage(f"Type of 'Error' column: {data['Error'].dtype}", 'Accuracy Metrics', Qgis.Info)
            QgsMessageLog.logMessage(f"Unique values in 'Error' column: {data['Error'].unique()}", 'Accuracy Metrics', Qgis.Info)

            return data

        except Exception as e:
            QgsMessageLog.logMessage(f"An error occurred during error calculation: {e}", 'Accuracy Metrics', Qgis.Critical)
            raise





    @staticmethod
    def calculateAbsoluteError(self, data, measured_field, estimated_field):
        """
        Calculate the Absolute Error.
        """
        data['Absolute Error'] = np.abs(data['Error'])
        return data
    
    @staticmethod
    def calculateRelativeError(self, data, measured_field, estimated_field):
        """
        Calculate the Relative Error.
        """
        data['Relative Error'] = data['Error'] / data[measured_field]
        return data

    @staticmethod
    def calculateAbsoluteRelativeError(self, data, measured_field, estimated_field):
        """
        Calculate the Absolute Relative Error.
        """
        data['Absolute Relative Error'] = np.abs(data['Relative Error'])
        return data
    


    @staticmethod
    def calculateMeanAbsoluteError(self, data, measured_field, estimated_field, case_field=None):
        """
        Calculate the Mean Absolute Error.
        """
        try:
            if case_field is not None:
                # Use the field calculator approach with expressions for grouped mean absolute errors
                expression = f"mean(\"Error\", group_by:=\"{case_field}\")"
                grouped_data = data.groupby(case_field, as_index=False).agg({'Error': 'mean'}).rename(columns={'Error': 'Mean Absolute Error'})
                
                # Handle empty values in case_field
                grouped_data[case_field] = grouped_data[case_field].fillna("Unknown")  # Replace empty values with "Unknown"
                
                data = pd.merge(data, grouped_data, on=case_field, how='left')
            else:
                # Calculate Mean Absolute Error for the entire dataset
                data['Error'] = pd.to_numeric(data['Error'], errors='coerce')  # Convert to numeric, coerce errors to NaN
                data['Mean Absolute Error'] = np.abs(data['Error']).mean()

            return data

        except Exception as e:
            QgsMessageLog.logMessage(f"An error occurred during Mean Absolute Error calculation: {e}", 'Accuracy Metrics', Qgis.Critical)
            raise